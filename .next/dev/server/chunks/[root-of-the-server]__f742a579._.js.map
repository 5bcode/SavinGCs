{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/G/Desktop/SavinGCs/lib/db.ts"],"sourcesContent":["import Database from 'better-sqlite3';\r\nimport { readFileSync } from 'fs';\r\nimport { join } from 'path';\r\nimport bcrypt from 'bcryptjs';\r\n\r\nconst dbPath = process.env.DATABASE_URL || join(process.cwd(), 'savings-tracker.db');\r\nconst db = new Database(dbPath);\r\n\r\n// Enable foreign keys\r\ndb.pragma('foreign_keys = ON');\r\n\r\n// Initialize database with schema\r\nexport function initializeDatabase() {\r\n  // In specific deployment environments (like Docker standalone), 'lib/schema.sql' might not be at process.cwd()/lib\r\n  // We should try to find it relative to __dirname or fallback. \r\n  // For standard nextjs standalone, it's often better to inline the schema or ensure execution directory is correct.\r\n  // We'll trust process.cwd() for now but log it.\r\n  const schemaPath = join(process.cwd(), 'lib', 'schema.sql');\r\n  // For production read-only filesystem where we might deploy with a pre-created DB, we might want to skip schema init if file exists?\r\n  // But better-sqlite3 handles 'IF NOT EXISTS' in SQL fine.\r\n\r\n  try {\r\n    const schema = readFileSync(schemaPath, 'utf-8');\r\n    db.exec(schema);\r\n  } catch (err) {\r\n    console.error(`Failed to read schema from ${schemaPath}`, err);\r\n    // If schema file is missing in production build, this might be fatal unless DB is pre-seeded.\r\n  }\r\n\r\n  // Migration: add owner column if it doesn't exist\r\n  const cols = db.prepare(\"PRAGMA table_info(accounts)\").all() as { name: string }[];\r\n  if (!cols.some(c => c.name === 'owner')) {\r\n    db.exec(\"ALTER TABLE accounts ADD COLUMN owner TEXT NOT NULL DEFAULT 'Joint'\");\r\n    console.log('Migration: added owner column to accounts');\r\n  }\r\n\r\n  // Create default users if they don't exist\r\n  const userCount = db.prepare('SELECT COUNT(*) as count FROM users').get() as { count: number };\r\n\r\n  if (userCount.count === 0) {\r\n    const salt = bcrypt.genSaltSync(10);\r\n    const defaultPassword = bcrypt.hashSync('loveyou', salt);\r\n\r\n    db.prepare(`\r\n      INSERT INTO users (username, password_hash, display_name)\r\n      VALUES (?, ?, ?)\r\n    `).run('gary', defaultPassword, 'Gary');\r\n\r\n    db.prepare(`\r\n      INSERT INTO users (username, password_hash, display_name)\r\n      VALUES (?, ?, ?)\r\n    `).run('catherine', defaultPassword, 'Catherine');\r\n\r\n    console.log('Created default users: gary and catherine');\r\n  }\r\n\r\n  // Ensure 'Unallocated' pot always exists (highest priority so it sorts first)\r\n  const unallocated = db.prepare(\"SELECT id FROM savings_pots WHERE name = 'Unallocated'\").get() as any;\r\n  if (!unallocated) {\r\n    db.prepare(`\r\n      INSERT INTO savings_pots (name, goal_amount, color, icon, priority)\r\n      VALUES ('Unallocated', NULL, '#64748B', 'savings', 9999)\r\n    `).run();\r\n    console.log('Created default pot: Unallocated');\r\n  }\r\n\r\n  console.log('Database initialized successfully');\r\n}\r\n\r\n// Initialize on import\r\ninitializeDatabase();\r\n\r\nexport default db;\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,YAAY,IAAI,IAAA,yGAAI,EAAC,QAAQ,GAAG,IAAI;AAC/D,MAAM,KAAK,IAAI,qNAAQ,CAAC;AAExB,sBAAsB;AACtB,GAAG,MAAM,CAAC;AAGH,SAAS;IACd,mHAAmH;IACnH,+DAA+D;IAC/D,mHAAmH;IACnH,gDAAgD;IAChD,MAAM,aAAa,IAAA,yGAAI,EAAC,QAAQ,GAAG,IAAI,OAAO;IAC9C,qIAAqI;IACrI,0DAA0D;IAE1D,IAAI;QACF,MAAM,SAAS,IAAA,6GAAY,EAAC,YAAY;QACxC,GAAG,IAAI,CAAC;IACV,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,CAAC,2BAA2B,EAAE,YAAY,EAAE;IAC1D,8FAA8F;IAChG;IAEA,kDAAkD;IAClD,MAAM,OAAO,GAAG,OAAO,CAAC,+BAA+B,GAAG;IAC1D,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,UAAU;QACvC,GAAG,IAAI,CAAC;QACR,QAAQ,GAAG,CAAC;IACd;IAEA,2CAA2C;IAC3C,MAAM,YAAY,GAAG,OAAO,CAAC,uCAAuC,GAAG;IAEvE,IAAI,UAAU,KAAK,KAAK,GAAG;QACzB,MAAM,OAAO,qKAAM,CAAC,WAAW,CAAC;QAChC,MAAM,kBAAkB,qKAAM,CAAC,QAAQ,CAAC,WAAW;QAEnD,GAAG,OAAO,CAAC,CAAC;;;IAGZ,CAAC,EAAE,GAAG,CAAC,QAAQ,iBAAiB;QAEhC,GAAG,OAAO,CAAC,CAAC;;;IAGZ,CAAC,EAAE,GAAG,CAAC,aAAa,iBAAiB;QAErC,QAAQ,GAAG,CAAC;IACd;IAEA,8EAA8E;IAC9E,MAAM,cAAc,GAAG,OAAO,CAAC,0DAA0D,GAAG;IAC5F,IAAI,CAAC,aAAa;QAChB,GAAG,OAAO,CAAC,CAAC;;;IAGZ,CAAC,EAAE,GAAG;QACN,QAAQ,GAAG,CAAC;IACd;IAEA,QAAQ,GAAG,CAAC;AACd;AAEA,uBAAuB;AACvB;uCAEe"}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/G/Desktop/SavinGCs/app/api/accounts/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport db from '@/lib/db';\r\n\r\nexport async function GET() {\r\n    try {\r\n        const accounts = db.prepare(`\r\n      SELECT \r\n        a.*,\r\n        sp.name as pot_name,\r\n        sp.color as pot_color\r\n      FROM accounts a\r\n      JOIN savings_pots sp ON sp.id = a.pot_id\r\n      ORDER BY sp.priority DESC, a.account_name ASC\r\n    `).all();\r\n\r\n        return NextResponse.json({ accounts });\r\n    } catch (error) {\r\n        console.error('Error fetching accounts:', error);\r\n        return NextResponse.json({ error: 'Failed to fetch accounts' }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const { potId, accountName, accountType, currentBalance, owner, startingBalanceDate } = await request.json();\r\n\r\n        const balance = parseFloat(currentBalance) || 0;\r\n        const ownerName = owner || 'Joint';\r\n\r\n        // Start a transaction\r\n        const createAccountTransaction = db.transaction(() => {\r\n            // 1. Get User ID based on owner name\r\n            // If Joint, we default to the first user (usually Gary id=1) or handle it.\r\n            // For now, let's try to find a user with display_name matching owner.\r\n            let userId = 1; // Default fallback\r\n            const user = db.prepare('SELECT id FROM users WHERE display_name = ?').get(ownerName) as { id: number } | undefined;\r\n            if (user) {\r\n                userId = user.id;\r\n            } else {\r\n                // For 'Joint' or unknown owners, we assign to the primary user (id 1) \r\n                // effectively treating them as the \"recorder\" of the transaction.\r\n                console.log(`Owner '${ownerName}' not found in users table, defaulting transaction to user id 1`);\r\n            }\r\n\r\n            // 2. Insert Account\r\n            const result = db.prepare(`\r\n              INSERT INTO accounts (pot_id, account_name, account_type, owner, current_balance, last_updated)\r\n              VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\r\n            `).run(potId, accountName, accountType, ownerName, balance);\r\n\r\n            const newAccountId = result.lastInsertRowid;\r\n\r\n            // 3. Insert Opening Balance Transaction if balance is non-zero\r\n            // Even if 0, maybe we should record it? User asked to \"record as opening balance\".\r\n            // Let's record it even if 0 so there is a history start point, or maybe only if != 0?\r\n            // Usually opening balance of 0 is implicit. But let's follow the \"record as opening balance\" instruction strictly.\r\n            // If they input a date, they expect a record.\r\n\r\n            if (balance !== 0 || startingBalanceDate) {\r\n                db.prepare(`\r\n                    INSERT INTO transactions (account_id, user_id, amount, description, transaction_date)\r\n                    VALUES (?, ?, ?, 'Opening Balance', ?)\r\n                 `).run(newAccountId, userId, balance, startingBalanceDate || new Date().toISOString().split('T')[0]);\r\n            }\r\n\r\n            return newAccountId;\r\n        });\r\n\r\n        const newAccountId = createAccountTransaction();\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            id: Number(newAccountId)\r\n        });\r\n    } catch (error) {\r\n        console.error('Error creating account:', error);\r\n        return NextResponse.json({ error: 'Failed to create account' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,WAAW,6IAAE,CAAC,OAAO,CAAC,CAAC;;;;;;;;IAQjC,CAAC,EAAE,GAAG;QAEF,OAAO,uKAAY,CAAC,IAAI,CAAC;YAAE;QAAS;IACxC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,uKAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA2B,GAAG;YAAE,QAAQ;QAAI;IAClF;AACJ;AAEO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc,EAAE,KAAK,EAAE,mBAAmB,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE1G,MAAM,UAAU,WAAW,mBAAmB;QAC9C,MAAM,YAAY,SAAS;QAE3B,sBAAsB;QACtB,MAAM,2BAA2B,6IAAE,CAAC,WAAW,CAAC;YAC5C,qCAAqC;YACrC,2EAA2E;YAC3E,sEAAsE;YACtE,IAAI,SAAS,GAAG,mBAAmB;YACnC,MAAM,OAAO,6IAAE,CAAC,OAAO,CAAC,+CAA+C,GAAG,CAAC;YAC3E,IAAI,MAAM;gBACN,SAAS,KAAK,EAAE;YACpB,OAAO;gBACH,uEAAuE;gBACvE,kEAAkE;gBAClE,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,UAAU,+DAA+D,CAAC;YACpG;YAEA,oBAAoB;YACpB,MAAM,SAAS,6IAAE,CAAC,OAAO,CAAC,CAAC;;;YAG3B,CAAC,EAAE,GAAG,CAAC,OAAO,aAAa,aAAa,WAAW;YAEnD,MAAM,eAAe,OAAO,eAAe;YAE3C,+DAA+D;YAC/D,mFAAmF;YACnF,sFAAsF;YACtF,mHAAmH;YACnH,8CAA8C;YAE9C,IAAI,YAAY,KAAK,qBAAqB;gBACtC,6IAAE,CAAC,OAAO,CAAC,CAAC;;;iBAGX,CAAC,EAAE,GAAG,CAAC,cAAc,QAAQ,SAAS,uBAAuB,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;YACxG;YAEA,OAAO;QACX;QAEA,MAAM,eAAe;QAErB,OAAO,uKAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,IAAI,OAAO;QACf;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,uKAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA2B,GAAG;YAAE,QAAQ;QAAI;IAClF;AACJ"}}]
}