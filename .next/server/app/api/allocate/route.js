"use strict";(()=>{var e={};e.id=632,e.ids=[632],e.modules={399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},6113:e=>{e.exports=require("crypto")},1017:e=>{e.exports=require("path")},4962:(e,t,r)=>{r.r(t),r.d(t,{originalPathname:()=>E,patchFetch:()=>A,requestAsyncStorage:()=>p,routeModule:()=>l,serverHooks:()=>w,staticGenerationAsyncStorage:()=>d});var a={};r.r(a),r.d(a,{POST:()=>i});var n=r(9303),s=r(8716),o=r(670),c=r(7070),u=r(4677);async function i(e){try{let t;let{sourceAccountId:r,targetPotId:a,amount:n}=await e.json();if(!r||!a||!n||n<=0)return c.NextResponse.json({error:"Invalid input"},{status:400});let s=(await u.wp.execute({sql:"SELECT * FROM accounts WHERE id = ?",args:[r]})).rows[0];if(!s)throw Error("Source account not found");if(Number(s.current_balance)<n)throw Error("Insufficient funds in source account");let o=(await u.wp.execute({sql:`SELECT * FROM accounts 
                  WHERE pot_id = ? 
                  AND account_name = ? 
                  AND account_type = ? 
                  AND owner = ?`,args:[a,s.account_name,s.account_type,s.owner]})).rows[0];if(o)t=String(o.id),await u.wp.execute({sql:`UPDATE accounts 
                      SET current_balance = current_balance + ?, last_updated = CURRENT_TIMESTAMP 
                      WHERE id = ?`,args:[n,t]});else{let e=await u.wp.execute({sql:`INSERT INTO accounts (pot_id, account_name, account_type, owner, current_balance, last_updated)
                      VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP) RETURNING id`,args:[a,s.account_name,s.account_type,s.owner,n]});t=String(e.lastInsertRowid||e.rows[0]?.id)}return await u.wp.execute({sql:`UPDATE accounts 
                  SET current_balance = current_balance - ?, last_updated = CURRENT_TIMESTAMP 
                  WHERE id = ?`,args:[n,r]}),c.NextResponse.json({success:!0,result:{sourceId:r,targetId:t}})}catch(e){return console.error("Allocation error:",e),c.NextResponse.json({error:e.message||"Allocation failed"},{status:500})}}let l=new n.AppRouteRouteModule({definition:{kind:s.x.APP_ROUTE,page:"/api/allocate/route",pathname:"/api/allocate",filename:"route",bundlePath:"app/api/allocate/route"},resolvedPagePath:"C:\\Users\\G\\Desktop\\SavinGCs\\app\\api\\allocate\\route.ts",nextConfigOutput:"",userland:a}),{requestAsyncStorage:p,staticGenerationAsyncStorage:d,serverHooks:w}=l,E="/api/allocate/route";function A(){return(0,o.patchFetch)({serverHooks:w,staticGenerationAsyncStorage:d})}},4677:(e,t,r)=>{r.d(t,{wp:()=>n});let a=require("@libsql/client");require("fs"),r(1017),r(8691),process.env.DATABASE_URL?.includes("libsql")||process.env.DATABASE_URL?.includes("turso");let n=(0,a.createClient)({url:process.env.DATABASE_URL||"file:savings-tracker.db",authToken:process.env.DATABASE_AUTH_TOKEN});class s{prepare(e){return{get:async(...t)=>(await n.execute({sql:e,args:t})).rows[0],all:async(...t)=>(await n.execute({sql:e,args:t})).rows,run:async(...t)=>{let r=await n.execute({sql:e,args:t});return{lastInsertRowid:r.lastInsertRowid,changes:r.rowsAffected}}}}transaction(e){return async(...t)=>(console.warn("Transactions are not fully supported in async wrapper yet."),e(t))}pragma(e){}exec(e){return n.executeMultiple(e)}}new s}};var t=require("../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),a=t.X(0,[948,972,691],()=>r(4962));module.exports=a})();